<link rel="import" href="../polymer/polymer.html">

<!-- <link rel="import" href="../iron-a11y-keys/iron-a11y-keys.html"> -->
<link rel="import" href="../iron-icons/iron-icons.html">

<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">

<link rel="import" href="../psi-external-deps/dependency-underscore.html">

<link rel="import" href="event-timeline-icons.html">
<link rel="import" href="timeline-styles.html">
<script type="text/javascript" src="timeline.js"></script>
<!--
`event-timeline`


@demo demo/index.html
-->

<dom-module id="event-timeline">
  <template>
    <style include="timeline-styles">
      
      :host {
        display: block;
      }
      .timeline-event-dot.type1 {
          background: url('img/error.svg') no-repeat;
      }
      
      .timeline-event-dot.type2 {
          background: url('img/warning.svg') no-repeat !important;
      }
      
      .timeline-event-dot.type3 {
          background: url('img/normal.svg') no-repeat;
      }
      
      .timeline-event-dot.type4 {
          background: url('img/maintenance.svg') no-repeat !important;
      }

    </style>
    
    <!-- <iron-a11y-keys target="[[fetchOnEnterInput]]" keys="enter" on-keys-pressed="_filter"></iron-a11y-keys> -->

    <paper-input id="filterInput" 
      placeholder="Filter stations"
      auto-validate
      autofocus
      value="{{_filterString::input}}">
        <paper-icon-button suffix icon="event-timeline-icons:search" on-tap="_filter"></paper-icon-button>
    </paper-input>


    <div id="timeline"></div>

    <div id="messages">
      
    </div>

  </template>

  <script>
    class EventTimeline extends Polymer.Element {
      
      static get is() { return "event-timeline"; }
      
      static get properties() {
        
        return {
          
          /**
           * [data description]
           * @type {Object}
           */
          _data: {
            type: Array,
            value: function() { return []; }
          },

          _filterString: {
            type: String
          },

          /**
           * URL for the custom CSS to be loaded.
           */
          cssUrl: {
            type: String
          },

          /**
           * Date the visible timeline start.
           */
          start: {
            type: String
          },

          /**
           * Date the visible timeline ends (exclusive).
           */
          end: {
            type: String
          },

          /**
           * This makes sure that clustering takes place.
           * @type {Object}
           */
          cluster: {
            type: Boolean,
            reflectToAttribute: true,
            value: false
          },

        };
      }

      static get observers() {
        return [
          "_dataChanged(_data.*)"
        ]
      }

      /**
       * Called when the element is upgraded (that is, when an element is created, 
       * or when a previously-created element becomes defined).
       * @return {[type]} [description]
       */
      constructor() {
        super();
      }

      /**
       * One time initialization.
       */
      ready() {
        super.ready();
        
        if (!_.isEmpty(this.cssUrl)) {
          this._appendExternalStylesheet(this.cssUrl);
        }

        // specify options
        var options = {
          width:           "100%",
          height:          "125px",
          cluster:         this.cluster,
          clusterMaxItems: 1,
        };
        // Instantiate our timeline object.
        this._timeline = new links.Timeline(this.$.timeline, options);
        if (!_.isEmpty(this.start) && !_.isEmpty(this.end)) {
          this._timeline.firstDraw = false; // overwrites the logic when draw() is first invoked
          this._timeline.setVisibleChartRange(new Date(this.start), new Date(this.end), true);
        }
        this._installCallbacks();
      }

      _filter() {
        console.log(this.$.channelInput.value);
      }

      /**
       * Lodas the external stylesheet configured by the user.
       */
      _appendExternalStylesheet(url) {
        var fileref=document.createElement("link");
        fileref.setAttribute("rel", "stylesheet");
        fileref.setAttribute("type", "text/css");
        fileref.setAttribute("href", url);
        this.shadowRoot.appendChild(fileref);
      }

      /**
       * Sets the callback methods needed for hover/click events.
       */
      _installCallbacks() {
        this._timeline.mouseoverItemEventCallback = this._mouseoverItemEventCallback;
        this._timeline.clickItemEventCallback     = this._clickItemEventCallback;
      }

      /**
       * Adds all the event objects in the array.
       */
      addAll(eventObjectsArray) {
        _.each(eventObjectsArray, function(eo) {
          this.addEvent(eo);
        }.bind(this))
      }

      /**
       * Adds an event to the list timeline if it passes the validation.
       */
      addEvent(eventObject) {
        if (eventObject) {
          var validation = this._validateRequiredProperties(eventObject);
          if(validation.isValid) {
            this.push("_data", this._extendEventObjectIfNecessary(eventObject));
          }
        }
      }

      /**
       * Makes sure that all necessary properties are set. Otherwise, init them with default values.
       */
      _extendEventObjectIfNecessary(eventObject) {
        if (eventObject) {
          if (!_.has(eventObject, "content")) {
            eventObject.content = "";
          }
        }

        return eventObject;
      }

      /**
       * Validates each timeline object.
       */
      _validateRequiredProperties(eventObject) {
        var validationObj = { isValid: true, msg: ""};

        if (!eventObject) {
          validationObj.isValid = false;
          validationObj.msg = "Event object is undefined.";
          return validationObj;
        } else if (!_.has(eventObject, "start")) {
          validationObj.isValid = false;
          validationObj.msg = "Field 'start' is missing.";
        }

        return validationObj;

      }

      /**
       * Re-draws the timeline.
       */
      _draw() {
        Polymer.RenderStatus.afterNextRender(this, function() {
          // Draw our timeline with the created data and options
          this._timeline.draw(_.map(this._data, function(d) { 
            // add a reference to each item to the timeline instance (for callback methods)
            d.timelineRef = this._timeline;
            return d;
          }.bind(this)));
        });
      }

      /**
       * Draws the timeline with the new data, including a 500ms delay.
       */
      _dataChanged(data) {
        this._debouncer = Polymer.Debouncer.debounce(
          this._debouncer, // initially undefined
          Polymer.Async.timeOut.after(500),
          function() { // callback
            this._draw()
          }.bind(this)
        );
        
      }

      /**
       * Callback invoked when over an event icon.
       */
      _mouseoverItemEventCallback(eventId) {
        console.log("hovered");
      }

      /**
       * Callback invoked when an event icon is clicked.
       */
      _clickItemEventCallback(eventId) {
        console.log("clicked");
      }

    }

    window.customElements.define(EventTimeline.is, EventTimeline);

  </script>
</dom-module>
