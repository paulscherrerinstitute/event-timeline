<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../iron-a11y-keys/iron-a11y-keys.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../iron-list/iron-list.html">

<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">

<link rel="import" href="../psi-external-deps/dependency-underscore.html">
<link rel="import" href="../psi-external-deps/dependency-vis.html">

<script type="text/javascript" src="timeline.js"></script>
<!-- <script type="text/javascript" src="timeline.min.js"></script> -->

<link rel="import" href="event-timeline-styles.html">
<link rel="import" href="event-timeline-item.html">
<link rel="import" href="event-timeline-icons.html">

<style is="custom-style" include="event-timeline-styles"></style>
<!--
`event-timeline`


@demo demo/index.html
-->

<dom-module id="event-timeline">
  <template>
    <style>
      
      :host {
        display: block;
      }
      paper-input {
        --paper-input-container-focus-color: #989fbd;
      }
      #filterInput {
        margin-bottom: 20px;
      }

    </style>
    
    <iron-a11y-keys target="[[fetchOnEnterInput]]" keys="enter" on-keys-pressed="_filter"></iron-a11y-keys>

    <paper-input id="filterInput" 
      placeholder="Filter stations"
      autofocus
      on-input="_filterDelayed">
        <paper-icon-button suffix icon="event-timeline-icons:search" on-tap="_filter"></paper-icon-button>
    </paper-input>


    <div id="timeline"></div>

    <div class="timelineEvents">
      <iron-list id="eventsList" class="eventsList"
        items="[[_rawEvents]]"
        hidden$="[[!_rawEvents.length]]" >
        <template>
          <event-timeline-item event="[[item]]" eventid$="[[item.event_id]]"></event-timeline-item>
        </template>
      </iron-list>
    </div>

  </template>

  <script>
      (function() {
    
    Polymer({
      
      is: "event-timeline", 

      properties: {

        /**
         * Array of the currently displayed events - both in the timeline as well as the list.
         */
        _rawEvents: {
          type: Array,
          value: function() { return []; }
        },

        /**
         * The vis dataset holding all data.
         */
        _events: {
          type: vis.DataSet
        },

        /**
         * Options to use when instantiating the DataSet instances.
         */
        _dsOptions: { 
          type: Object,
          value: function() { 
            return { // specifies the name of the field which acts as ID in the dataset
              fieldId: "event_id",
            };
          }
        },

        /**
         * Contains all filter terms as a list.
         * List gets automatically populated whenever the user inputs into the filter field
         */
        _filterList: {
          type: Array,
          value: function() { return []; }
        },

        /**
         * URL for the custom CSS to be loaded.
         */
        cssUrl: {
          type: String
        },

        /**
         * Date the visible timeline start.
         */
        start: {
          type: String
        },

        /**
         * Date the visible timeline ends (exclusive).
         */
        end: {
          type: String
        },

        /**
         * Enables clustering.
         */
        enableCluster: {
          type: Boolean,
          reflectToAttribute: true,
          value: false
        },
        /**
         * Connects the keyboard enter event to the startDateInput event when that element has the focus.
         * @type {Object}
         */
        fetchOnEnterInput: {
          type: Object,
          value: function() {
            return this.$.filterInput;
          }
        }

      },
      
      /**
       * One time initialization.
       */
      ready: function() {
        
        this._initDataset();

        if (!_.isEmpty(this.cssUrl)) {
          this._appendExternalStylesheet(this.cssUrl);
        }

        // specify options
        var options = {
          width:           "100%",
          height:          "125px",
          cluster:         this.enableCluster,
          clusterMaxItems: 1
        };
        // Instantiate our timeline object.
        this._timeline = new links.Timeline(this.$.timeline, options);
        this._checkStartEnd();
        this._installCallbacks();
      },

      /**
       * Initializes the dataset instance.
       */
      _initDataset: function() {
        this._events = new vis.DataSet(this._dsOptions);
        this._installListeners();
      },

      /**
       * Installs a change listener on the items dataset so that any changes are reflected in the simple Array.
       */
      _installListeners: function() {
        this._events.on("*", function(event, properties, senderId) {
          
          this.debounce("update-events", function() {
            this._rawEvents = this._events.get();
            this.$.filterInput.value = "";
            this._checkStartEnd();
            // now re-draw the timeline
            this._draw();
          }.bind(this), 500);
          
        }.bind(this));
      },

      /**
       * [_checkStartEnd description]
       * @return {[type]} [description]
       */
      _checkStartEnd: function() {
        if (!_.isEmpty(this.start) && !_.isEmpty(this.end)) {
          this._timeline.firstDraw = false; // overwrites the logic when draw() is first invoked
          this._timeline.setVisibleChartRange(new Date(this.start), new Date(this.end), true);
        }
      },

      /**
       * Invoked automatically when user types into the filter input. Delays execution 500ms.
       */
      _filterDelayed: function(e) {
        var splitValues = this.$.filterInput.value.split(",");
        this._filterList = _.map(splitValues, function(entry) { return entry.trim(); });
        this.debounce("filter-input", this._filter, 500);
      },

      /**
       * Filters out the station that are currently visibly in range.
       */
      _filter: function(e) {
        var range = this._timeline.getVisibleChartRange();
        var filterStartEnd = { filter: function (event) { 
          return this._isInRange(range, event) && this._matchesStation(this._filterList, event);
        }.bind(this) };
        
        this._rawEvents = this._events.get(filterStartEnd);
        this._draw(); // make sure we update the elements from the timeline too
      },

      /**
       * Lodas the external stylesheet configured by the user.
       */
      _appendExternalStylesheet: function(url) {
        var filere = document.createElement("link");
        fileref.setAttribute("rel", "stylesheet");
        fileref.setAttribute("type", "text/css");
        fileref.setAttribute("href", url);
        this.shadowRoot.appendChild(fileref);
      },

      /**
       * Sets the callback methods needed for hover/click events.
       */
      _installCallbacks: function() {
        // adds the listener to the timeline instance
        links.events.addListener(this._timeline, "rangechanged", function(range) {
          
          var filterStartEnd = { filter: function (event) { 
            return this._isInRange(range, event) && this._matchesStation(this._filterList, event);
          }.bind(this) };
          
          this._rawEvents = this._events.get(filterStartEnd);
          this._draw(); // make sure we update the elements from the timeline too

          this.fire("timeline-move-zoom", range);

        }.bind(this));

        this._timeline.mouseoverItemEventCallback = this._mouseoverItemEventCallback.bind(this);
        this._timeline.clickItemEventCallback     = this._clickItemEventCallback.bind(this);
      },

      /**
       * Returns true if 1) no station has been specified or the regular expression of the 
       * specified station matches the station value in the `event` object.
       * 
       * @param  {String} station name of the station to be tested against
       * @param  {Object} event   object as saved in the `_events` array
       */
      _matchesStation: function(stationList, event) {
        if (_.isEmpty(stationList)) {
          return true;
        } else {
          // station is set
          if (_.isEmpty(event.station)) {
            return false;
          }

          var anyMatchList = _.map(stationList, function(station) {
            var regex = new RegExp(station.toLowerCase());
            return regex.test(event.station.toLowerCase());
          });
          // true if any of the matches is true
          return _.some(anyMatchList);

        }
      },

      /**
       * Returns true if the event is inside
       * 
       * @param  {Object}  event object containing `start`, or `start` and `end` properties (Date)
       */
      _isInRange: function(range, event) {
        if (event.end) {
          // Time range
          if (range.start <= event.start && event.end <= range.end) {
            return true;
          }
        } else {
          // Point object
          if (range.start <= event.start && event.start <= range.end) {
            return true;
          }
        }
        return false;
      },

      /**
       * Clears all events.
       */
      clear: function(redraw) {
        this._events.clear();
        if (redraw) {
          this._draw();
        }
      },

      /**
       * Adds an event to the list timeline if it passes the validation.
       */
      add: function(eventObject) {
        if (eventObject) {
          eventObject = this._extendEventObjectIfNecessary(eventObject)
          var validation = this._validateRequiredProperties(eventObject);
          if(validation.isValid) {
            this._events.update(eventObject);
          } else {
            throw new Error(validation.msg);
          }
        }
      },

      /**
       * Adds all the event objects in the array.
       */
      addAll: function(eventObjectsArray) {
        _.each(eventObjectsArray, function(eo) {
          this.add(eo, false);
        }.bind(this))
      },

      /**
       * Returns a mutable list of all events.
       */
      getAll: function() {
        return this._events.get();
      },

      /**
       * Gets the events based on the field `event_id`.
       * @param  {Array} eventIds Array of all event ids to be retrieved
       */
      getByIds: function(eventIds, eventsToCheck) {
        if (eventIds) {
          var filtered = _.filter(eventsToCheck, function (event) { 
            // this O(n^2), however, we're not expecting huge lists so it should suffice
            return _.contains(eventIds, event.event_id);
          });
          return filtered;
        }
        return [];
      },

      /**
       * Gets the event index based on the field `event_id`.
       * @param  {Array} eventIds Array of all event ids to be retrieved
       */
      getIndexByIds: function(eventIds, eventsToCheck) {
        if (eventIds) {
          return _.findIndex(eventsToCheck, function(event) {
            return _.contains(eventIds, event.event_id);
          });
        }
        return -1;
      },

      /**
       * Re-draws the timeline.
       */
      _draw: function() {
        var data = _.map(this._rawEvents, function(d) { 
          // add a reference to each item to the timeline instance (for callback methods)
          d.timelineRef = this._timeline;
          return d;
        }.bind(this));
        
        this.async(function() { 
          this._timeline.draw(data);
        }.bind(this), 1);
      },

      /**
       * Makes sure that all necessary properties are set. Otherwise, init them with default values.
       */
      _extendEventObjectIfNecessary: function(eventObject) {
        if (eventObject) {
          if (!_.has(eventObject, "content")) {
            eventObject.content = "";
          }
          if (!_.has(eventObject, "start")) {
            eventObject.start = new Date();
          }
        }
        return eventObject;
      },

      /**
       * Validates each timeline object.
       */
      _validateRequiredProperties: function(eventObject) {
        var validationObj = { isValid: true, msg: ""};

        if (!eventObject) {
          validationObj.isValid = false;
          validationObj.msg = "Event object is undefined.";
          return validationObj;
        } else if (!_.has(eventObject, "start")) {
          validationObj.isValid = false;
          validationObj.msg = "Field 'start' is missing.";
        } else if (!_.has(eventObject, "event_id")) {
          validationObj.isValid = false;
          validationObj.msg = "Field 'event_id' is missing.";
        }
        return validationObj;
      },

      /**
       * Callback invoked when over an event icon.
       */
      _mouseoverItemEventCallback: function(events) {
        _.each(this.getByIds(events, this._rawEvents), function(event) {
          var elem = this.$$('event-timeline-item[eventid="' + event.event_id + '"]');
          elem.setHighlighted();
        }.bind(this));
      },

      /**
       * Callback invoked when an event icon is clicked.
       */
      _clickItemEventCallback: function(events) {
        var index = this.getIndexByIds(events, this._rawEvents);
        if (index > -1) {
          this.$.eventsList.scrollToIndex(index);
          
          var elem = this.$$('event-timeline-item[eventid="' + this._rawEvents[index].event_id + '"]');
          if (elem) {
            elem.setHighlighted();
          }
        }
      }


    });
  })();


  </script>
</dom-module>
